### 암묵적 입력과 출력은 적을수록 좋다 (p.91)

- `암묵적 입력` : 인자가 아닌 모든 입력
- `암묵적 출력` : 리턴값이 아닌 모든 출력, 쓰기 행위
- `계산` : 암묵적 입력과 출력이 없는 함수
- `다른 컴포넌트와 강하게 연결된 컴포넌트`
    - 암묵적 입력과 출력이 있는 어떤 함수
    - 다른 곳에서 사용할 수 없기 때문에 `모듈이 아님`
- `모듈화된 컴포넌트`
    - 명시적 입력과 출력이 있는 어떤 함수
    - 명시적 입력과 출력은 모듈에 있는 커넥터와 같다

**암묵적 입력과 출력있을 때의 어려운 점**

- 암묵적 입력과 출력이 있는 함수는 다른 곳에 영향을 주기 때문에 조심해서 사용해야 한다.
- 암묵적 입력과 출력이 있는 함수는 아무 때나 실행할 수 없기 때문에 테스트하기 어렵다.

### 설계는 엉켜있는 코드를 푸는 것이다 (p.98)

- 함수를 사용하면 관심사를 자연스럽게 분리할 수 있습니다
- 함수는 인자로 넘기는 값과 그 값을 사용하는 방법을 분리합니다.

**좋은 설계**

- **재사용하기 쉽다**
    - 함수는 작으면 작을수록 재사용하기 쉽다
    - 하는 일도 적고 쓸 때 가정을 많이 하지 않아도 된다
- **유지보수하기 쉽다**
    - 작은 함수는 쉽게 이해할 수 있고 유지보수하기 쉽다.
    - 코드가 작기 때문에 올바른지 아닌지 명확하게 알 수 있다
- **테스트하기 쉽다**
    - 작은 함수는 테스트하기 좋다
    - 한 가지 일만 하기 때문에 한 가지만 테스트하면 된다.
    - 함수에 특별한 문제가 없어도 꺼낼 것이 있다면 분리하는 것이 좋다

### 카피-온-라이트 원칙과 세 단계 (p.112)

`불변성 법칙 == 카피-온-라이트`

**카피-온-라이트 규칙**
(아래의 불변성을 유지하면서 값을 바꿀 수 있는 세 단계를 구현하면 카피-온-라이트로 동작)

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

### 얕은 복사와 구조적 공유 (p.133)

- **얕은 복사**
    - 데이터 구조의 최상위 단계만 복사하는 것
- **구조적 공유**
    - 두 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조
    - 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다
    - 구조적 공유는 메모리를 적게 사용하고 모든 것을 복사하는 것보다 빠름


### 방어적 복사는 원본이 바뀌는 것을 막아줍니다 (p.150)

- `안전지대 안으로 들어온 데이터` : 깊은 복사본을 만들고 원본은 버림
- `안전지대 밖으로 나가는 데이터` : 깊은 복사본을 만들어 내보냄

### 방어적 복사 (p.151)

- **정의 및 특징**
    - 데이터를 변경할 수도 있는 코드와 불변성 코드 사이에 데이터를 주고받기 위한 원칙
    - 데이터가 바뀌는 것을 완벽히 막아 불변성을 지킬 수 있다
    - 원본이 바뀌지 않도록 막아주어 방어적이라고 한다
- **목적**
    - 안전지대에 불변성을 유지하고 바뀔 수도 있는 데이터가 안전지대로 들어오지 못하도록 하는 것
- **동작 방식**
    - 들어오고 나가는 데이터의 복사본을 만드는 방식으로 동작

### 방어적 복사 규칙 (p.152)

`깊은 복사` : 위에서 아래로 모든 계층에 있는 중첩된 데이터 구조를 복사

- **데이터가 안전한 코드에서 나갈 때 복사하기**
    1. 불변성 데이터를 위한 깊은 복사본을 생성
    2. 신뢰할 수 없는 코드로 복사본을 전달
- **안전한 코드로 데이터가 들어올 때 복사하기**
    1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 생성하여 안전한 코드로 전달
    2. 복사본을 안전한 코드에서 사용



### 얕은 복사(shallow copy) vs 깊은 복사(deep copy)

- `얕은 복사` : 얕은 복사 (Shallow Copy):
객체나 배열을 복사할 때, 원본 객체의 속성들을 복사하여 새로운 객체에 넣는 것을 의미한다. 그러나 속성 값이 참조형 데이터(객체나 배열)인 경우, 복사된 객체와 원본 객체가 같은 참조를 가리키게 된다. 이렇게 복사된 객체의 내부 참조형 데이터는 여전히 원본 객체와 공유된다.

- `깊은 복사` (Deep Copy):
객체나 배열을 복사할 때, 원본 객체의 모든 내부 속성들을 재귀적으로 복사하여 완전히 새로운 객체를 생성하는 것을 의미한다. 이렇게 복사된 객체는 원본 객체와 완전히 분리되어 있으며, 내부의 참조형 데이터 역시 모두 새로운 인스턴스로 복사된다.

```jsx
// 원본 객체
import { cloneDeep } from 'lodash-es';

const originalObject = {
  a: 1,
  b: [2, 3],
};

// 얕은 복사
const shallowCopy = { ...originalObject };
// 또는 const shallowCopy = Object.assign({}, originalObject);
shallowCopy.b.push(4);

console.log(originalObject.b);  // [2, 3, 4]

// 깊은 복사
const deepCopy = cloneDeep(originalObject);
deepCopy.b.push(5);

console.log(originalObject.b);  // [2, 3, 4]

```

### cloneDeep