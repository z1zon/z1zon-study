## 파트 1: 액션과 계산, 데이터

함수형 사고 중 가장 기본적인 것은 **코드를 액션과 계산, 데이터로 구분**하는 것이다.
액션과 계산, 데이터 이 세 가지를 구분하는 이유는 우리가 코드를 대할 때, 쉽게 다룰 수 있는 부분과 조심히 다뤄야 할 부분을 명확하게 하기 위함이다.

### 액션

호출 횟수와 시점에 의존하는 것. 말 그대로 호출하는 시점과 횟수에 따라 결과가 달라질 수 있기 때문에 가장 조심히 다뤄야 한다.

- 반죽 펴기
- 피자 배달
- 재료 주문

### 계산

입력 값을 활용하여 어떤 것을 계산하는 것. 실행 시점과 횟수에 의존하지 않는다.

- 조리법에 나온 것을 두 배로 만들기
- 쇼핑 목록 결정

### 데이터

의미를 가지고 있는 변경 불가능한 값. 데이터는 네트워크 전송 혹은 그 자체로 쓰임이 있다.

- 고객 주문
- 영수증
- 조리법

## 계층화 설계

변경 가능성에 따라 자주 바뀌는 것부터 자주 바뀌지 않는 것으로 계층을 나눈 아키텍처 패턴을 **계층형 설계**라고 부른다.

자주 바뀌는 것을 가장 위에 두고 아래로 내려갈수록 자주 바뀌지 않는 것으로 나눈다. 계층 위에서 아래로 갈수록 의존성이 강해진다. 가장 위에 있는 계층은 의존성이 거의 없기 때문에 변화에 쉽게 대응할 수 있고 그래서 자주 바뀌는 것을 가장 위에 두는 것이다.
아래 있는 코드들은 의존성이 많아 바꾸기 어렵지만 자주바뀌지 않는다.

## 파트 2: 일급 추상

타임라인 다이어그램을 사용하여 액션이 시간 순서에 따라 어떻게 실행되는지 볼 수 있다.

> 액션은 실행 시점에 의존하기 때문에 실행 순서가 중요

[사진]

로봇 한 대가 타임라인 하나를 모두 책임지고 있기 때문에 피자 하나를 만드는 시간이 오래걸린다.

아래는 분산시스템을 타임라인으로 시각화한 이미지

[사진2]

위의 분산시스템의 문제점은 **각각의 타임라인이 다른 순서로 실행**된다는 것이다.

서로 다른 타임라인에 있는 액션 간 실행 순서는 보장할 수 없다.

- 소스가 먼저 완성되고 반죽이 나중에 완성될 수도 있다. 이 경우 소스를 만드는 로봇은 반죽이 나오기도 전에 반죽을 펴는 작업을 시작한다.

타임라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다. 제대로 동작하기 위해서는 **타임라인 커팅** 이라고 부르는 기술을 사용하여 순서를 맞출 수 있다. (17장에서 배움)

타임라인 커팅은 고차 동작으로 구현한다. 각 타임라인은 독립적으로 동작하고 작업이 완료되면 다른 타임라인이 끝나기를 기다리기 때문에 어떤 타임라인이 먼저 끝나던지 상관없다. (어떻게?)
