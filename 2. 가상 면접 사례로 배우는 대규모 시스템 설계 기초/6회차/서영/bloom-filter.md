# Bloom Filters

- https://youtu.be/V3pzxngeLqw?si=iNQR3EgeBp9V-IK2
- 공간 효율적인 확률적 데이터 구조
  - 적은 공간으로 이 데이터가 있는지 없는지 알려줄 수 있음

## 어디에 사용되나?

- NoSQL 데이터베이스
  - Bloom 필터를 사용하여 디스크에 해당 키가 존재하는지 확인, 존재하지 않는 키라면 디스크를 읽지 않아도 됨
- CDN에서 한번만 요청되는 페이지의 캐싱을 방지
  - 블룸 필터를 사용해서 표시된 모든 URL을 추적하고 **두번째 요청에서만** 페이지를 캐싱
- 웹 브라우저에서 악성 URL을 식별할 때
  - (사용했었는데 더 효율적이지만 복잡한 방법이 필요해져서 이젠 안씀)

## 특징

### 1. 거짓 긍정을 사용

![](./imgs/Pasted%20image%2020240127232805.png)

- 블룸필터의 대답은: Firm No 또는 Probably Yes
- 거짓 긍정(false positive)
  - 해당 요소가 없지만 블룸필터는 있다고 말해줌 (Probably Yes)
  - 거짓 부정(있지만 없다고 하는것)은 불가능
  - 블룸필터가 **확률적**이라고 말하는 이유
- Trade Off
  - 가끔 잘못된 거짓 긍정 답변을 제공하는 대가로 (항상 완벽한 답변을 제공하는 해시 테이블 같은 데이터 구조보다) **훨씬 적은 메모리**를 소비한다

### 2. 블룸필터에서 항목을 삭제할 수 없다

??

## 작동원리

- 블룸필터는 각 버킷이 단일 비트를 포함하고 모두 0으로 시작하는 대규모 버킷 set
  ![](./imgs/Pasted%20image%2020240127233114.png)

- 일단 블룸 필터를 적용하려면 좋은 hash function이 필요함 - 빠르고 - 균등하고 무작위로 분산된 출력을 생성해야 함 - 충돌은 ㄱㅊ지만 드물어야 함
  ![](./imgs/Pasted%20image%2020240127235558.png)

### 예시: 내가 좋아하는 음식인지 아닌지 알려주는 블룸필터

1. 내가 좋아하는 음식 등록

‘ribeye’를 input으로 세 개의 해시함수를 돌림 -> 결과: 1, 3, 4 -> 블룸필터에 마킹
![](./imgs/Pasted%20image%2020240127233220.png)

potato’를 input으로 세 개의 해시함수를 돌림 -> 결과: 0, 4, 8 -> 블룸필터에 마킹
![](./imgs/Pasted%20image%2020240127233248.png)

2. 이 블룸필터에서 'pork chop'이 있는지 여부 검색하려면?

‘pork chop'을 input으로 세 개의 해시함수를 돌림 -> 결과: 0,5,8 -> 5번 버킷은 0이므로 'pork chop'은 내가 좋아하는 음식이 아님!
![](./imgs/Pasted%20image%2020240127233350.png)

‘lemon'을 input으로 세 개의 해시함수를 돌림 -> 결과: 1,4,8 -> 있을 수도 있음! (하지만 없을 수도 있음 -> 거짓 긍정)
![](./imgs/Pasted%20image%2020240127233452.png)

- 즉, 효율적인 공간을 사용하는 대신, 100% 정확하진 않을 수도 있다
  - trade-offs between **space used and accuracy**
- 블룸필터에서 정확도를 높이려면?
  - 비트 수를 늘리거나 해쉬 함수 개수를 늘려서 정확도를 높일 수 있다.
