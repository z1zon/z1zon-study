# 뉴스 피드 시스템 설계

## 개략적 설계안 제시

### 피드 발행 (feed publishing)

- 피드 발행 API (*POST /v1/me/feed*)
  - 새 스토리를 포스팅하기 위한 API
    - body: 포스팅 내용
    - Authorization header: API 호출 인증을 위해 사용

- 피드 읽기 API (*GET /v1/me/feed*)
   - 뉴스 피드를 가져오는 API 
     - Authorization header: API 호출 인증을 위해 사용

- 사용자가 포스팅을 올리면, 
  1. 포스팅 저장 서비스 (post service)에서 새로운 포스팅을 DB와 Cache에 저장함
  2. 포스팅 전송 서비스 (fanout service)에서 새로운 포스팅을 친구의 뉴스 피드에 푸시함 
  3. 알림 서비스 (notification service)에서 친구들에게 새로운 포스팅이 올라왔다고 알림을 줌

### 뉴스 피드 생성 (news feed building)

- 사용자가 뉴스 피드 영역에 들어오면,
  1. 뉴스 피드 서비스 (news feed service)는 캐시에서 뉴스 피드를 가져옴
  2. 뉴스 피드 캐시 (news feed cache)는 뉴스 피드 렌더링에 필요한 피드 ID을 보관함

## 상세설계

### 포스팅 전송 (fanout) 서비스 

1. **fanout-on-write (=push) model**

- 새로운 포스팅이 기록되는 시점에 뉴스 피드를 갱신함
- 장점:
  - 새로운 포스팅이 기록되는 순간에 뉴스 피드가 실시간으로 갱신됨
  - 사용자가 뉴스피드에 들어갈 때 뉴스피드는 이미 갱신된 상태로 빨리 업데이트된 상태를 볼 수 있음
- 단점:
  - 팔로어가 많은 사용자의 경우 친구 목록에 속한 모든 사용자의 뉴스 피드를 갱신하는데 많은 시간이 소요될 수 있음 (=hot key problem)
  - 서비스를 자주 사용하지 않는 사용자의 피드를 실시간으로 갱신하는 것은 컴퓨팅 리소스 낭비임

2. **fanout-on-read (=pull) model**

- 사용자가 뉴스 피드를 읽으려는 시점(=on demand)에 뉴스 피드를 갱신함
- 장점:
  - 비활성화된 사용자에게 컴퓨팅 리소스를 낭비하지 않아도 됨
  - hot key problem이 발생하지 않음
- 단점:
  - 뉴스 피드를 읽기까지 많은 시간이 소요될 수 있음

3. **fanout-on-write + fanout-on-read model**

- 대부분의 사용자들에 대해서는 fanout-on-write 모델을 적용하여 뉴스 피드가 실시간으로 갱신되도록 함 
- 팔로어가 많은 사용자의 경우에는 fanout-on-read 모델을 적용하여 팔로어가 뉴스 피드를 읽으려할 때 갱신하도록 함

### 뉴스 피드 캐시
- fanout 서버가 메시지 큐에서 뉴스 피드 데이터를 뉴스 피드 캐시에 넣음
- 뉴스 피드 캐시에는 <포스팅 ID, 사용자 ID> 데이터 쌍을 보관함
- 뉴스 피드 서비스는 뉴스 피드 캐시에서 사용자별 포스팅 ID 목록을 불러온 후 사용자 캐시와 포스팅 캐시에서 데이터를 불러와 완전한 뉴스 피드를 만듦
- 캐시 구조
  - 뉴스 피드: 포스팅 ID 보관
  - 콘텐츠: 포스팅 데이터 보관 (인기, 일반)
  - 소셜 그래프: 사용자 간의 관계 보관 (팔로어, 팔로잉)
  - 행동: 포스팅에 대한 사용자 행위 정보 보관 (좋아요, 답글, 기타)
  - 횟수: 좋아요 횟수, 답글 횟수, 기타 정보 등을 보관

