# 키-값 저장소 설계

## CAP 정리

분산 시스템 상에서,

- Consistency 데이터 일관성
  - 어떤 노드에 접근하던 언제나 같은 데이터를 보아야 함
- Availability 가용성
  - 특정 노드에 장애가 발생하더라도 항상 정상 응답을 받아야 함
- Partition Tolerance theorem 파티션 감내
  - 두 노드 사이에 통신 장애가 발생해도 시스템은 정상 동작해야 함

* 3가지 조건 중 2가지만 충족 가능

- CP (데이터 일관성 + 파티션 감내) or AP (가용성 + 파티션 감내)
- 분산 시스템의 세계에서는 파티션 문제를 피할 수 없음
  - 그럼 문제는 데이터 일관성과 가용성 중 어떤 것을 택할 것인가?

### 데이터 파티션

- 대규모 application에서 전체 데이터를 1대의 서버에 저장하는 것은 현실적으로 불가능한 일
- 데이터를 작은 파티션으로 분할한 후 여러 대의 서버에 저장하는 방법이 있음 ◄ `consistent hash` 기법
  - 데이터를 여러 서버에 고르게 분산할 수 있는가
  - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가
- 데이터 파티션의 장점
  1. 규모 확장 자동화 (automatic scaling)
     - 시스템 부하에 따라 서버를 자동으로 추가 혹은 삭제 가능
  2. 다양성 (heterogeneity)
     - 서버의 용량에 맞게 가상 노드의 수를 조정 가능

### 데이터 다중화 (replication)

- 높은 가용성과 안정성 확보를 위해 데이터를 N개의 서버에 비동기적으로 다중화
  - 이 때 같은 물리 서버를 중복 선택하지 않도록 하는 것이 좋음
    - 같은 데이터 센터에 속한 노드는 문제를 같이 겪을 가능성이 높기 때문

### 데이터 일관성

- 정족수 합의 (Quorum Consensus) 프로토콜을 사용해 여러 노드에 다중화된 데이터의 읽기/쓰기 연산 모두에 일관성 유지 가능
  - N = 사본 개수
  - W = 쓰기 연산에 대한 정족수, W개의 서버로부터 쓰기 연산에 성공했다는 응답 받아야 함
  - R = 읽기 연산에 대한 정족수, R개의 서버로부터 읽기 연산에 성공했다고 응답 받아야 함
- R = 1, W = N: 빠른 읽기 연산에 최적화된 시스템
- W = 1, R = N: 빠른 쓰기 연산에 최적화된 시스템
- W + R > N: 강한 일관성이 보장됨
- W + R <= N: 강한 일관성이 보장되지 않음

### 일관성 모델

- 강한 일관성: 오로지 up-to-date 데이터만 반환하는 케이스
- 약한 일관성: out-of-date 데이터를 반환할 가능성이 있는 케이스
- 결과적 일관성: 약한 일관성의 한 형태로 갱신 결과가 결국에 모든 사본에 동기화되는 모델
  - 벡터 시계 (vector clock)
    - D([S1, v1], [S2, v2], ..., [Sn, vn]) (D=데이터, S=서버, v=버전)
    - [Si, vi]가 있다면 vi+1, 그렇지 않다면 새로운 항목 [Si, 1]
    - 어떤 버전 X, Y 사이의 충돌이 있는지 확인하는 방법 => Y의 벡터 시계 구성요소 중 X보다 작거나 같은 값이 있는 경우 충돌 발생

### 장애 감지

- 분산 시스템 상에서는 서버 1대가 죽었다고 장애 처리를 하지 않고, 2대 이상의 서버가 장애를 보고해야 장애 처리를 함

  - 모든 노드 사이의 multicasting 구축
    - 서버의 개수가 늘어나면 비효율적
  - 분산형 장애 감지 방법 (ex. gossip protocol)
    - 각 노드는 무작위로 선정된 노드들에게 주기적으로 데이터 목록 업데이터를 요청하고, 지정된 시간 동안 데이터가 갱신되지 않은 노드를 장애 노드로 간주함

- 일시적 장애

  - 엄격한 정족수 (strict quorum) 접근법
    - 읽기 + 쓰기 연산 금지
  - 느슨한 정족수 (sloppy quorum) 접근법
    - 정족수의 요구사항을 지키는 대신 W + R 요청을 수행할 수 있는 건강한 서버를 해시링에서 골라서 처리함
    - 장애 서버가 복구되었을 때 장애 상황 동안 발생했던 변경사항들을 일괄 반영하여 결과적 데이터 일관성 유지

- 영구적 장애
  - anti-entropy protocol을 통해 사본들을 비교하며 최신 버전으로 갱신함
  - Merkle tree (=Hash tree) 자료구조
    - root node의 해시값을 비교하는 것으로 시작해 해시 값이 일치하지 않은 노드 간의 데이터를 동기화하는 작업을 진행함
