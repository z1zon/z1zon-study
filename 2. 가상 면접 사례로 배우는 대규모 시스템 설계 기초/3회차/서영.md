# 5장 안정 해시 설계

수평적 규모 확장성을 달성하려면 **요청 또는 데이터를 서버에 균등하게 나누는 것**이 중요

## 해시 키 재배치(rehash) 문제

`serverIndex = hash(key) % N (N: 서버 개수)`

위의 해시 함수를 사용하는 경우 서버 풀 크기가 고정되어 있고, 데이터 분포가 균등할 땐 잘 동작한다.
하지만, 서버가 추가되거나 삭제될 경우, 키가 재분배 되고, 이 때 대규모 캐시 미스(cache miss)가 발생하게 된다.
-> 따라서 안정 해시가 필요

## 안정 해시 (consistent hash)

해시 테이블 크기가 조정될 때 평균적으로 **k/n개의 키만 rehash** (k: 키의 개수, n: slot 개수)

- 해시 공간과 해시 링
  - 해시 공간 : x0 ~ xn (0 ~ 2^160 - 1)
  - 해시 공간을 동그랗게 말아 해시링을 만듦
- 해시 서버 & 해시 키 : 해시 함수 f(Ex. SHA-1)를 이용해서 서버 IP나 이름을 해시 링 위 어디든 배치 가능 (해시 키도)
- 서버 조회 : 어떤 키 k가 저장되는 서버는 해당 키의 위치로부터 시계방향으로 가서 만나는 첫번째 서버다.
- 서버 추가 & 제거 : 이렇게 하면 서버를 추가하거나 제거하더라도 키 가운데 일부만 rehash 하면 됨 (나머지 키에는 영향이 없음!)

### 기본 구현법의 두 가지 문제

1. 서버가 추가되거나 삭제될 때 파티션을 균등하게 유지하는게 불가능
   - 파티션: 인접한 서버 사이의 해시 공간
   - 특정 서버만 큰 해시 공간을 할당 받을 수도 (Ex. s0,s2 사이의 s1이 사라지는 경우 s2의 파티션은 나머지의 2배가 됨)
2. 키의 균등 분포(uniform distribution)를 달성하기가 어렵다.
   - 특정 서버에 키가 몰릴 수도

## 가상 노드 (virtual node)

- 위 문제를 해결하기 위해 가상 노드(virtual node) 또는 복제(replica) 기법 도입
- 가상노드: 실제 노드 또는 서버를 **가리키는** 노드
  - Ex. s0의 가상노드 3개: s0_1, s0_2, s0_3 (실제로는 훨씬 많은 개수의 가상 노드를 사용)
    -> 각 서버는 하나가 아닌 여러 개의 파티션을 관리
- 키 k는 k에서 시계방향으로 링을 돌다가 만나는 최초의 **가상노드(Ex. s1_2)**에 해당하는 서버(Ex. s1)에 저장
- 가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다!!
  - 표준 편차가 작아서저 데이터가 고르게 분표
  - 하지만, 반대로 **가상 노드 데이터를 저장할 공간**이 늘어나므로 둘 사이의 균형을 잘 맞춰야함
