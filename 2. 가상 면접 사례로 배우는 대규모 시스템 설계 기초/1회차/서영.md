# 1장. 사용자 수에 따른 규모 확장성 (p.1 ~ p.31)

## 단일 서버
웹 앱, 데이터베이서스, 캐시가 전부 서버 한 대에서 실행

단일 서버 설계의 문제점
- 사용자가 웹 서버에 바로 연결되기 때문에 웹서버가 죽으면 사용자가 웹사이트에 접속할 수 없다.
- 너무 많은 사용자가 접속하면 웹 서버가 느려질 수도 있다.

사용자가 늘면 여러 서버를 두어야 한다. 
서버를 용도에 따라 분리 -> 각각을 독립적으로 확장
1. 웹/모바일 트래픽 처리 서버 (웹 계층)
2. 데이터베이스 서버 (데이터 계층)

## 수직적 규모 확장 vs 수평적 규모 확장

1. 수직적 규모 확장 (scale up) - 서버 사양을 높임 (더 좋은 CPU, 더 많은 RAM)
2. 수평적 규모 확장 (scale out) - 서버 개수를 늘림

- 서버로 유입되는 트래픽 양이 적은 경우 수직적 확장이 좋음. 하지만, 
	- 🔴 한계가 있음 (한 대의 서버에 CPU나 메모리를 무한대로 증설할 순 x, 비쌈)
	- 🔴 SPOF (Single Point Of Failure)
		- 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다 
		- 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단
- 따라서 대규모 애플리케이션을 지원하는 데는 **수평적 규모 확장법**이 적절함!

### 로드밸런서 (load balancer)

- 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 **트래픽 부하를 고르게 분산**하는 역할
- 로드밸런서를 사용하면 
	- 사용자(클라이언트)는 서버에 직접 접속하는 것이 아니라 **로드벨런서의 공개 IP주소**로 접속
	- 서버 간 통신에는 ==**사설 IP 주소**== 이용
		- 사설 IP 주소: **같은 네트워크에 속한 서버 사이**의 통신에만 쓰일 수 있는 IP 주소 (인터넷을 통해 접속할 수 x)

- 부하 분산 집합에 또 하나의 웹 서버를 추가하면
	- 장애를 자동복구하지 못하는 문제(No failover) 해소
		- ex) 서버 1이 다운되면 모든 트래픽은 서버2로 전송된다.
	- 웹 계층의 가용성(availability) 향상
		- (가용성: 서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도)
- 로드밸런서가 자동으로 트래픽을 분산하기 떄문에, 트래픽이 감당할 수 없는 시점이 와도 웹 서버 계층에 서버를 추가하기만 하면 됨

<details>
<summary>로드밸런싱 알고리즘</summary>
<div markdown="1">	
1. 라운드로빈 방식 (Round Robin Method) 
	- 서버에 들어온 요청을 순서대로 돌아가면 배정
	- 여러 대의 서버가 동일한 스펙, 서버와의 연결이 오래 지속되지 않는 경우 적합
2. 가중 라운드로빈 방식 (Weighted Round Robin Method)
	- 각 서버마다 가중치를 매김, 가중치가 높은 서버 순으로 클라이언트 요청 배분
	- 서버 트래픽 처리 능력이 상이한 경우 사용
3. IP 해시 방식 (IP Hash Method)
	- 클라이언트의 IP 주소를 특정 서버로 매핑
	- 사용자가 항상 동일한 서버로 연결되는 것 보장
4. 최소 연결 방식 (Least Connection Method)
	- 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 트래픽 배분
	- 자주 세션이 길어지거나, 서버에 분배된 트래픽이 일정하지 않은 경우 적합
5. 최소 응답시간 (Least Response Time Method)
	- 서버의 현재 연결상태와 응답시간 모두 고려. 
	- 가장 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드 배분


(+ 추가)
 - 상위 계층에서 사용되는 장비는 하위 계층의 장비가 갖고 있는 기능을 모두 포함하므로 상위 계층으로 갈수록 정교한 로드밸런싱이 가능
	- L4 (전송계층) 로드밸런서: TCP/UDP 포트 정보를 바탕으로 함
	- L7 (응용계층) 로드밸런서: TCP/UDP 포트 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키 정보 등을 바탕으로 함
</div>
</details>


### 데이터베이스 다중화

- 서버 사이에 **주(master)-부(salve) 관계**를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식
	- 주 데이터베이스 - 쓰기 연산 (insert, delete, update 등)
	- 부 데이터베이스 - 읽기 연산
-  데이터베이스 다중화의 이점
	1. 더 나은 성능 - 병렬로 처리될 수 있는 질의(query) 수가 늘어나므로 성능이 좋아짐 (쓰기는 주 db, 읽기는 부 db)
	2. 안정성 - 자연재해 등으로 데이터베이스 서버 일부가 파괴되어도 데이터가 보존 (데이터를 지역적으로 떨어진 여러 장소에 다중화 시켜놓을 수 있기 때문)
	3. 가용성 - 데이터를 여러 지역에 복제해두었으므로 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버에 있는 데이터 가져다 쓰면 됨

## 캐시

- 비싼 연산 결과나 자주 참조되는 데이터를 메모리에 잠시 보관 (다음 요청이 더 빨리 처리될 수 있게끔)
- 캐시 계층을 추가하면? 
	- 성능 개선
	- 데이터베이스 부하 줄임
	- 캐치 계층의 규모를 독립적으로 확장 가능
- 캐시할 데이터 종류, 크기, 액세스 패턴에 따라 ==다양한 캐시 전략==이 있음
- 캐시 사용 시 고려햘 것 - 어떤 데이터를 캐싱할지, 만료 기한, 일관성, 캐시 메모리, 데이터 방출 정책 (LRU, LFU, FIFO), SPOF를 피하기 위해 캐시 서버도 분산

## CDN (콘텐츠 전송 네트워크)

- 정적 콘텐츠(이미지, CSS, JavaScript 파일)를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크
- 사용자에게 가까운 CDN 서버로부터 콘텐츠 전달 받음, 파일 캐시
- CDN 사용 시 고려사항 - 비용, 적절한 만료 시한, 장애 대처, 콘텐츠 무효화 방법

## 무상태(stateless) 웹 계층

- 웹 계층을 수평적으로 확장하려면 상태 정보(Ex. 사용자 세션 데이터)를 웹 계층에서 제거해야 한다.
- 무상태 아키텍처 - 상태 정보를 공유 저장소(shared storage)에 저장
	- 공유 저장소는 웹 서버로부터 물리적으로 분리

## 데이터 센터
-  2개의 데이터 센터 사용
	- 장애 x -> 사용자는 가장 가까운 데이터 센터로 안내 (지리적 라우팅, geoDNS-routing)
	- 하나의 데이터 센터에 장애 o -> 모든 트래픽은 장애가 없는 데이터 센터로 전송
- 다중 데이터센터 아키텍처 고려사항
	- 트래픽 우회 - 올바른 데이터 센터로 트래픽을 보내는 방법
	- 데이터 동기화 - 보편적으로 데이터 다중화 방식 사용

<details>
<summary>카카오 판교 데이터 센터 화재</summary>
<div markdown="1">
https://if.kakao.com/2022/session/112
- 카카오는 세 곳 이상의 데이터 센터에 다양한게 분산 배치 & 데이터 이중화
- 그럼에도 장애가 났던 이유?
	- 판교 데이터 센터 화재 -> 서버 다운 -> 모니터링 및 분석툴이 마비되어 장애 탐지가 원활하기 이뤄지지 못함
	- **서버 이동 및 재설치에 필요한 환경 구성 정보**가 대부분 판교 데이터 센터의 시스템에 있었음
	- **운영관리 도구 일부가 이중화 되지 않아** 장애 초기 개발자들이 서비스를 복구할 시간이 지연됨 (특히 앱 배포 도구..)
 		- 운영관리 도구 : 사내 계정 인증, 소스 관리/앱 배포 도구, 위키, 지라 등의 협업도구 등
	- 플랫폼 도구 클러스터도 데이터센터 간 이중화가 되어 있지 않은 부분이 있었음

- 대첵 : 모니터링 시스템 다중화, 데이터&운영관리 도구 등 2중화 -> 3중화, 자체 데이터 센터,.. 등등

+ 일시에 많은 서비스 장애로 많은 수의 서비스 복구 시 우선순위 판단의 어려웠음 -> 각 도구의 목적, 영향도 및 중요도 파악 프로세스 도입, 특정 시스템 장애 시 영향을 받는 대상에 대한 공지 자동화할 예정
</div>
</details>

## 메시지 큐
- 메시지의 **무손실**을 보장하는 **비동기** 통신을 지원하는 컴포넌트 (==서버에서 컴포넌트란?==)
	- 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전하다.
	- 메시지의 버퍼 역할
- 서비스 또는 서버 간 결합이 느슨해짐
	- 규모 확장성 보장, 안정적 애플리케이션 구성에 좋음
	- 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 받을 수 있고, 소비자는 생산자 서비스를 사용할 수 없는 상태라도 메시지를 보낼 수 있다!!
- Ex. 이미지 보정 어플리케이션 - 보정 시간이 오래걸림 -> 비동기로 처리

## 로그, 메트릭 그리고 자동화
- 로그  - 에러 로그 모니터링
- 메트릭 - 성능 모니터링, 시스템의 현재 상태 쉽게 파악
- 자동화 - CI/CD, 개발 생산성 향상

## 데이터베이스의 규모 확장
1. 수직적 규모 확장: CPU, RAM, 디스크 등 자원 증설
2. 수평적 규모 확장: 서버 증설

### 샤딩 (데이터 베이스의 수평적 확장)
- 대규모 데이터베이스르 샤드(shard)라고 부르는 작은 단위로 나누는 기술
- 샤드에 보관되는 데이터 사이에는 중복 x
- 샤딩 전략을 구현할 때 가장 중요한 것은 샤딩 키를 정하는 법
	- 데이터를 고르게 분할 할 수 있게 하는게 중요
- 데이터의 재 샤딩(resharding)
	- 아래와 같은 경우 샤드키를 계산하는 함수를 변경하고 데이터를 재배치 해야한다.
		- 데이터가 너무 많아져서 샤드를 확장해야 할 때
		- 샤드 간 데이터가 고르게 분포되지 않아 특정 샤드의 공간 소모가 빠를 때 (샤드 소진) 
- 유명인사 문제
	- 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
		- Ex. 저스틴 비버, 레이디 가가 - read 연산에 과부하
- 조인과 비정규화
	- 하나의 데이터베이스를 여러 샤드 서버로 쪼개면, 여러 샤드에 걸친 데이터를 조인하기 어려워짐
	- 해결법: 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 함

<details>
<summary>샤딩 방법, 샤딩 vs 파티셔닝</summary>
<div markdown="1">
1. 범위 기반 샤딩 : 범위에 따라 데이터베이스 행 분할 (레인지 샤딩)
	- Ex. 고객 이름의 첫번째 알파벳에 따라 데이터 분할
	- 장점:  구현하기 쉬움, 단점: 하나의 범위에 데이터가 몰릴 수 있음
2. 해시 샤딩  : 해시 함수 사용하여 데이터베이스 각 행에 샤드 키 할당 (모듈러 샤딩?)
	- 장점: 데이터를 고르게 분산, 단점: 정보의 의미에 따라 분류 x, 물리적 샤드를 추가할때 해시 값을 재할당 할 때 어려울 수도
3. 디렉터리 샤딩 : 조회 테이블 사용, 키 매핑 하는 느낌 (?)
	- Ex. 파란 옷 - A, 빨간 옷  - B, 노란 옷 - C ...
	- 장점: 각 샤드는 데이터베이스의 의미 있는 표현, 단점: 조회 테이블에 잘못된 정보가 포함 -> 샤딩 실패
4.  지리적 샤딩 : 지리적 위치에 따라 분할
	- 장점: 샤들와 요청하는 고객 간 거리가 짧아 애플리케이션 정보를 더 빠르게 검색, 단점: 데이터가 고르지 않게 분산될 수 있다.

- 샤딩 vs 파티셔닝
	- 둘다 데이터베이스를 여러개의 행 그룹으로 분할
	- 파티셔닝 - 모든 데이터 그룹을 동일한 컴퓨터에 저장, 샤딩 - 서로 다른 컴퓨터에 분산
</div>
</details>

## 요약
- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
