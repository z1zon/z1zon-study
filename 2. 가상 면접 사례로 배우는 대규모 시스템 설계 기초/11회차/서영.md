# 13장. 검색어 자동완성 시스템

## 1. 트라이 자료구조

### 관계형 데이터 베이스를 사용할 경우?

```sql
SELECT * FROM frequency_table
WHERE query Like `prefix%`
ORDER BY frequency DESC
LIMIT 5
```

이런 SQL 질의문을 사용해서 'top 5' 검색어를 뽑아낸다.
데이터가 많지 않은 경우 이 방법도 괜찮지만, 데이터가 많아질 경우 데이터베이스에 병목이 생길 수 있다.

### 트라이란?

- 문자열을 간략하게 저장할 수 있는 트리 형태의 자료구조

### 트라이 시간 복잡도

```
p: 접두어(prefix)의 길이
n: 트라이 안에 있는 노드 개수
c: 주어진 노드의 자식 노드 개수
```

1. 어떤 접두어로 시작하는 검색어 중, 'top K'를 찾는데 걸리는 시간?
   - (단계 1) 해당 접두어를 표현하는 노드를 찾는다. => `O(p)`
   - (단계 2) 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다 => `O(c)`
   - (단계 3) 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다 => `O(clogc)`

- 총 걸린 시간: `O(p) + O(c) + O(clogc) `
- 하지만, 최악의 경우 트리 전체를 탐색해야 한다.

2. 1번을 개선해보자!
   1. 접두어 최대 길이 제한
      - (단계 1) 과정이 걸리는 시간이 `O(p)`에서 `O(1)`로 줄어든다
      - (p가 충분히 작은 값일테니 1(작은 상수값)로 봐도 됨)
   2. 노드에 인기 검색어 캐시!
      - 이렇게 각 인기 질의어를 캐시한다. -> 응답 속도가 엄청 빨라짐! (대신 저장공간 희생)
      - 전체 트라이를 탐색하는 것 방지
      - 인기 검색어 k개 찾는 시간 => `O(1)` (결과가 이미 캐시 되어 있기 때문에)

### 트라이 연산

1. Create
   - 작업 서버가 담당, 데이터 분석 서비스의 로그나 데이터 베이스로부터 취합된 데이터를 사용
2. Update
   - 매주 한번 갱신 (서비스의 실시간성 중요도에 따라 달라짐)
   - 노드를 개별적으로 갱신하는 방법은 트라이가 작을때는 ㄱㅊ (성능이 좋지 않음)
3. Delete
   - 혐오, 폭력적, 노골적인 검색어들은 필터 계층을 통해 자동완성 결과에서 제거한다.

## 2. 데이터 수집 서비스

- 사용자가 입력한 질의 실시간으로 수집

### 설계

```
데이터 분석 서비스 로그 -> 로그 취합 서버 -> 취합된 데이터 -> 작업 서버 -> 트라이 데이터 베이스 -> 트라이 캐시
```

- 데이터 분석 서비스 로그: 질의에 관한 원본 데이터 보관
  - 데이터가 추가만 됨 (수정 x)
  - ex) `tree, 2024-04-03 22:00:10`, `try, 2024-04-03 22:00:26`
- 로그 취합(aggregation) 서버: 로그를 취합해서 서용하기 편한 형태로 관리
- 취합된 데이터 (ex) `query, time, frequncy`)
  - `tree, 2024-04-03, 12000`, `tree, 2024-04-06, 15000`
- 작업 서버: 트라이 자료구조를 만들고 데이터 베이스에 저장
- 트라이 캐시: 데이터를 메모리에 저장, 매주 트라이 데이터베이스 스냅샷 갱신
- 트라이 데이터베이스

## 3. 질의 서비스

- 주어진 질의에 k개의 인기 검색어 정렬해서 반환

### 설계

```
검색 질의 -> 로드밸런서 -> API 서버 (트라이 캐시 or 트라이 데이터베이스로부터 자동완성 검색어 제안 응답 생성)
```

## 4. 규모 확장이 가능한 저장소

- 샤딩 적용
  - 알파벳으로 샤딩
    ex) 서버 1: `a-i` , 서버 2: `j-r` , 서버 3: `s-z`
  - s로 시작하는 검색어 양이 u,v,w,x,y,z로 시작하는 검색어 양보다 많을 수도 있음
    => 검색어 대응 샤드 관리자를 통해 어떤 검색어가 어느 저장소 서버에 있는지 관리
