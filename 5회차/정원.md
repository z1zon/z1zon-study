## chap 12 - í•¨ìˆ˜í˜• ë°˜ë³µ

```
ğŸ’¡ reduceë¡œëŠ” filter, mapì„ êµ¬í˜„í•  ìˆ˜ ìˆì§€ë§Œ filter, mapìœ¼ë¡œëŠ” reduceë¥¼ ë§Œë“¤ ìˆ˜ ì—†ë‹¤
```


### lodash-es  `groupBy` êµ¬í˜„ íŒŒë³´ê¸°

**`groupBy`**

```jsx
import baseAssignValue from './.internal/baseAssignValue.js';
import reduce from './reduce.js';

/** Used to check objects for own properties. */
const hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * groupBy([6.1, 4.2, 6.3], Math.floor)
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 */
function groupBy(collection, iteratee) {
    return reduce(
        collection,
        (result, value, key) => {
            key = iteratee(value);
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                baseAssignValue(result, key, [value]);
            }
            return result;
        },
        {},
    );
}

export default groupBy;
```

**`reduce`**

```jsx
import arrayReduce from './.internal/arrayReduce.js';
import baseEach from './.internal/baseEach.js';
import baseReduce from './.internal/baseReduce.js';

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `reduce`, `reduceRight`, and `transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see reduceRight, transform
 * @example
 *
 * reduce([1, 2], (sum, n) => sum + n, 0)
 * // => 3
 *
 * reduce({ 'a': 1, 'b': 2, 'c': 1 }, (result, value, key) => {
 *   (result[value] || (result[value] = [])).push(key)
 *   return result
 * }, {})
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
    const func = Array.isArray(collection) ? arrayReduce : baseReduce;
    const initAccum = arguments.length < 3;
    return func(collection, iteratee, accumulator, initAccum, baseEach);
}

export default reduce;
```

**`arrayReduce`**

```jsx
/**
 * A specialized version of `reduce` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  let index = -1
  const length = array == null ? 0 : array.length

  if (initAccum && length) {
    accumulator = array[++index]
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array)
  }
  return accumulator
}

export default arrayReduce
```

**`baseReduce`**

```jsx
/**
 * The base implementation of `reduce` and `reduceRight` which iterates
 * over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, (value, index, collection) => {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection)
  })
  return accumulator
}

export default baseReduce
```

## chap 13 - í•¨ìˆ˜í˜• ë„êµ¬ ì²´ì´ë‹

### ì—°ìŠµë¬¸ì œ p351

ìš”êµ¬ì‚¬í•­ - ë†’ì€ ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬ëœ í‰ì  ëª©ë¡ê³¼ ë‚®ì€ ì ìˆ˜ìˆœìœ¼ë¡œ ì •ë ¬ëœ í‰ì  ëª©ë¡ ë§Œë“¤ê¸°

```tsx
import { cloneDeep } from 'lodash-es';

class ObjectListSorter<TObject> {
  private clonedList;

  constructor(listToSort: TObject[]) {
    this.clonedList = cloneDeep(listToSort);
  }

  sort(iteree: (item: TObject) => number, type: 'ASC' | 'DEC'): TObject[] {
    const func = (itemA: TObject, itemB: TObject) =>
      type === 'ASC' ? iteree(itemA) - iteree(itemB) : iteree(itemB) - iteree(itemA);
    return this.clonedList.sort(func);
  }
}

type ObjectType = {
  name: string;
  position: string;
  score: number;
};

const recommendations = employeeNames.map((name) => ({
  name,
  position: recommendPosition(name),
}));

const evaluations = recommendations.map((item) => ({
  ...item,
  score: scorePlayer(item.name, item.position),
}));

// ì ìˆ˜ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ëŠ” í•¨ìˆ˜
const sortScoreInAscendingOrder = () => {
  const evaluationSorter = new ObjectListSorter<ObjectType>(evaluations);
  return evaluationSorter.sort((item: ObjectType) => item.score, 'ASC');
};

// ì ìˆ˜ë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ëŠ” í•¨ìˆ˜
const sortScoreInDescendingOrder = () => {
  const evaluationSorter = new ObjectListSorter<ObjectType>(evaluations);
  return evaluationSorter.sort((item: ObjectType) => item.score, 'DEC');
};
```
